/**
 * text-mine-api
 * text-mine
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType } from '@angular/http';

import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';


@Injectable()
export class DocumentsApi {

  protected basePath = 'http://localhost:8080';
  public defaultHeaders: Headers = new Headers();
  public configuration: Configuration = new Configuration();

  constructor(protected http: Http, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
    }
  }

  /**
   *
   * @summary Delete document by id
   * @param id Document id
   */
  public _delete(id: string, extraHttpRequestParams?: any): Observable<string> {
    return this._deleteWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Delete document by id
   * @param id Document id
   */
  public deleteAttachments(id: string, extraHttpRequestParams?: any): Observable<string> {
    return this.deleteAttachmentsWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get document by corpus id
   * @param id Corpus Id
   */
  public getByCorpus(id: string, extraHttpRequestParams?: any): Observable<Array<models.Document>> {
    return this.getByCorpusWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get attachment by id
   * @param attachmentId Attachment id
   */
  public getFile(attachmentId: string, extraHttpRequestParams?: any): Observable<Array<string>> {
    return this.getFileWithHttpInfo(attachmentId, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get filtered documents
   * @param entryText Entry text
   * @param pos Parts of speech
   * @param entryWord Entry words
   * @param documentId Document ids
   * @param offset Offset
   * @param limit Limit
   */
  public getFiltered(entryText?: string, pos?: Array<string>, entryWord?: Array<string>, documentId?: Array<string>,
      offset?: number, limit?: number, extraHttpRequestParams?: any): Observable<Array<models.Document>> {
    return this.getFilteredWithHttpInfo(entryText, pos, entryWord, documentId, offset, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get filtered lines of section
   * @param id Document id
   * @param serial Section number
   * @param phrase Phrases
   */
  public getFilteredLines(id: string, serial: number, phrase?: Array<string>, extraHttpRequestParams?: any): Observable<models.LineHits> {
    return this.getFilteredLinesWithHttpInfo(id, serial, phrase, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get filtered sections
   * @param id Document Id
   * @param phrase Phrases
   * @param pos Parts of speech
   * @param slop Sloppy distance
   * @param disjoint Collections are ALL or ANY?
   */
  public getFilteredPages(id: string, phrase?: Array<string>, pos?: Array<string>, slop?: number, disjoint?: boolean,
      extraHttpRequestParams?: any): Observable<models.SectionHits> {
    return this.getFilteredPagesWithHttpInfo(id, phrase, pos, slop, disjoint, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get filtered sections
   * @param id Document Id
   * @param phrase Phrases
   * @param pos Parts of speech
   * @param slop Sloppy distance
   * @param disjoint Collections are ALL or ANY?
   */
  public getFilteredSections(id: string, phrase?: Array<string>, pos?: Array<string>, slop?: number,
      disjoint?: boolean, extraHttpRequestParams?: any): Observable<models.SectionHits> {
    return this.getFilteredSectionsWithHttpInfo(id, phrase, pos, slop, disjoint, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get document by Id
   * @param id Document Id
   */
  public getOne(id: string, extraHttpRequestParams?: any): Observable<models.Document> {
    return this.getOneWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get page PartOfSpeech shingle statistics
   * @param id Document id
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getPagePosShingleStats(id: string, pos: Array<string>, limit?: number,
      extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getPagePosShingleStatsWithHttpInfo(id, pos, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get page shingle statistics
   * @param id Document id
   * @param limit Limit
   */
  public getPageShingleStats(id: string, limit?: number, extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getPageShingleStatsWithHttpInfo(id, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get PartOfSpeech shingle statistics
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getPosShingleStats(pos: Array<string>, limit?: number, extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getPosShingleStatsWithHttpInfo(pos, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get PartOfSpeech statistics
   * @param id Document id
   */
  public getPosStats(id: string, extraHttpRequestParams?: any): Observable<Array<models.PartOfSpeechStatistics>> {
    return this.getPosStatsWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get section PartOfSpeech shingle statistics
   * @param id Document id
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getSectionPosShingleStats(id: string, pos: Array<string>, limit?: number,
      extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getSectionPosShingleStatsWithHttpInfo(id, pos, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get section shingle statistics
   * @param id Document id
   * @param limit Limit
   */
  public getSectionShingleStats(id: string, limit?: number, extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getSectionShingleStatsWithHttpInfo(id, limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get shingle statistics
   * @param limit Limit
   */
  public getShingleStats(limit?: number, extraHttpRequestParams?: any): Observable<Array<models.PosShingleEntry>> {
    return this.getShingleStatsWithHttpInfo(limit, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Normalize document by id
   * @param id Document id
   */
  public normalize(id: string, extraHttpRequestParams?: any): Observable<string> {
    return this.normalizeWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Update document by id
   * @param body Document
   * @param id Document id
   */
  public put(body: models.Document, id: string, extraHttpRequestParams?: any): Observable<models.Document> {
    return this.putWithHttpInfo(body, id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Get page PartOfSpeech shingle statistics
   * @param id Document id
   */
  public reindex(id: string, extraHttpRequestParams?: any): Observable<models.Document> {
    return this.reindexWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }


  /**
   * Delete document by id
   *
   * @param id Document id
   */
  public _deleteWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling _delete.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Delete,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Delete document by id
   *
   * @param id Document id
   */
  public deleteAttachmentsWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/${id}/attachments'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling deleteAttachments.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Delete,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get document by corpus id
   *
   * @param id Corpus Id
   */
  public getByCorpusWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/by-corpus/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getByCorpus.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get attachment by id
   *
   * @param attachmentId Attachment id
   */
  public getFileWithHttpInfo(attachmentId: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/attachment/${attachmentId}'
      .replace('${' + 'attachmentId' + '}', String(attachmentId));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'attachmentId' is not null or undefined
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error('Required parameter attachmentId was null or undefined when calling getFile.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/octet-stream'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get filtered documents
   *
   * @param entryText Entry text
   * @param pos Parts of speech
   * @param entryWord Entry words
   * @param documentId Document ids
   * @param offset Offset
   * @param limit Limit
   */
  public getFilteredWithHttpInfo(entryText?: string, pos?: Array<string>, entryWord?: Array<string>,
      documentId?: Array<string>, offset?: number, limit?: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents';

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    if (entryText !== undefined) {
      queryParameters.set('entryText', <any>entryText);
    }

    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (entryWord) {
      entryWord.forEach((element) => {
        queryParameters.append('entryWord', <any>element);
      });
    }

    if (documentId) {
      documentId.forEach((element) => {
        queryParameters.append('documentId', <any>element);
      });
    }

    if (offset !== undefined) {
      queryParameters.set('offset', <any>offset);
    }

    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get filtered lines of section
   *
   * @param id Document id
   * @param serial Section number
   * @param phrase Phrases
   */
  public getFilteredLinesWithHttpInfo(id: string, serial: number, phrase?: Array<string>,
      extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/sections/${id}/lines/${serial}'
      .replace('${' + 'id' + '}', String(id))
      .replace('${' + 'serial' + '}', String(serial));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getFilteredLines.');
    }
    // verify required parameter 'serial' is not null or undefined
    if (serial === null || serial === undefined) {
      throw new Error('Required parameter serial was null or undefined when calling getFilteredLines.');
    }
    if (phrase) {
      phrase.forEach((element) => {
        queryParameters.append('phrase', <any>element);
      });
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get filtered sections
   *
   * @param id Document Id
   * @param phrase Phrases
   * @param pos Parts of speech
   * @param slop Sloppy distance
   * @param disjoint Collections are ALL or ANY?
   */
  public getFilteredPagesWithHttpInfo(id: string, phrase?: Array<string>, pos?: Array<string>,
      slop?: number, disjoint?: boolean, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/pages/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getFilteredPages.');
    }
    if (phrase) {
      phrase.forEach((element) => {
        queryParameters.append('phrase', <any>element);
      });
    }

    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (slop !== undefined) {
      queryParameters.set('slop', <any>slop);
    }

    if (disjoint !== undefined) {
      queryParameters.set('disjoint', <any>disjoint);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get filtered sections
   *
   * @param id Document Id
   * @param phrase Phrases
   * @param pos Parts of speech
   * @param slop Sloppy distance
   * @param disjoint Collections are ALL or ANY?
   */
  public getFilteredSectionsWithHttpInfo(id: string, phrase?: Array<string>, pos?: Array<string>,
      slop?: number, disjoint?: boolean, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/sections/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getFilteredSections.');
    }
    if (phrase) {
      phrase.forEach((element) => {
        queryParameters.append('phrase', <any>element);
      });
    }

    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (slop !== undefined) {
      queryParameters.set('slop', <any>slop);
    }

    if (disjoint !== undefined) {
      queryParameters.set('disjoint', <any>disjoint);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get document by Id
   *
   * @param id Document Id
   */
  public getOneWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getOne.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get page PartOfSpeech shingle statistics
   *
   * @param id Document id
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getPagePosShingleStatsWithHttpInfo(id: string, pos: Array<string>, limit?: number,
      extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/pages/${id}/pos/shingle/stats'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getPagePosShingleStats.');
    }
    // verify required parameter 'pos' is not null or undefined
    if (pos === null || pos === undefined) {
      throw new Error('Required parameter pos was null or undefined when calling getPagePosShingleStats.');
    }
    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get page shingle statistics
   *
   * @param id Document id
   * @param limit Limit
   */
  public getPageShingleStatsWithHttpInfo(id: string, limit?: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/pages/${id}/shingle/stats'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getPageShingleStats.');
    }
    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get PartOfSpeech shingle statistics
   *
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getPosShingleStatsWithHttpInfo(pos: Array<string>, limit?: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/pos/shingle/stats';

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'pos' is not null or undefined
    if (pos === null || pos === undefined) {
      throw new Error('Required parameter pos was null or undefined when calling getPosShingleStats.');
    }
    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get PartOfSpeech statistics
   *
   * @param id Document id
   */
  public getPosStatsWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/pos/stats/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getPosStats.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get section PartOfSpeech shingle statistics
   *
   * @param id Document id
   * @param pos Parts of speech
   * @param limit Limit
   */
  public getSectionPosShingleStatsWithHttpInfo(id: string, pos: Array<string>, limit?: number,
      extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/sections/${id}/pos/shingle/stats'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getSectionPosShingleStats.');
    }
    // verify required parameter 'pos' is not null or undefined
    if (pos === null || pos === undefined) {
      throw new Error('Required parameter pos was null or undefined when calling getSectionPosShingleStats.');
    }
    if (pos) {
      pos.forEach((element) => {
        queryParameters.append('pos', <any>element);
      });
    }

    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get section shingle statistics
   *
   * @param id Document id
   * @param limit Limit
   */
  public getSectionShingleStatsWithHttpInfo(id: string, limit?: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/sections/${id}/shingle/stats'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getSectionShingleStats.');
    }
    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get shingle statistics
   *
   * @param limit Limit
   */
  public getShingleStatsWithHttpInfo(limit?: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/shingle/stats';

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    if (limit !== undefined) {
      queryParameters.set('limit', <any>limit);
    }

    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Normalize document by id
   *
   * @param id Document id
   */
  public normalizeWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/${id}/normalize'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling normalize.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'text/plain'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Post,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Update document by id
   *
   * @param body Document
   * @param id Document id
   */
  public putWithHttpInfo(body: models.Document, id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling put.');
    }
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling put.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    headers.set('Content-Type', 'application/json');

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Put,
      headers: headers,
      body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Get page PartOfSpeech shingle statistics
   *
   * @param id Document id
   */
  public reindexWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/documents/reindex/${id}'
      .replace('${' + 'id' + '}', String(id));

    const queryParameters = new URLSearchParams();
    const headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling reindex.');
    }
    // to determine the Content-Type header
    const consumes: string[] = [
    ];

    // to determine the Accept header
    const produces: string[] = [
      'application/json;charset=UTF-8'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Post,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

}
